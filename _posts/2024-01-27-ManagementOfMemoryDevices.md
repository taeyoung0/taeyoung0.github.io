---
title : "[기억장치 관리]기억장치의 관리 전략, 가상 기억장치 "

excerpt : "반입 전략, 배치 전략, 교체 전략, 가상 기억장치"

categories:
- 운영체제

tags: 
- [Blog, Github, Git, Memory]

last_modified_at : "2024-01-27"
  

toc: true
toc_sticky: true
pin: true
---

## 기억장치의 관리 전략

1. 반입(Fetch) 전략 / 중요★

보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략 

- 요구 반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법

- 예상 반입 : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

 

2. 배치(Placement) 전략 / 중요★

새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략

- 최초 적합(First Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영영에 배치시키는 방법

- 최적 적합(Best Fit) : 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법

- 최악 적합(Worst Fit) : 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

* 단편화 : 데이터를 할당할 경우 생기는 빈 기억 공간

 

3. 교체(Replacement) 전략 / 중요★

주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 

어느 영역을 교체하여 사용할 것인지를 결정하는 전략

- FIFO, OPT, LRU, LFU, NUR, SCR 등이 있음

**기억장치 계층 구조**

![image](https://github.com/taeyoung0/taeyoung0.github.io/assets/115425415/554bb88d-4b26-4f6b-bbfb-6932af27a750)

## 가상 기억장치

보조기억장치의 일부를 주기억장치처럼 사용하는 것, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법.

- 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리.  

- 내부 단편화 : 프로그램이 할당된 후 사용되지 않고 남아있는 공간

- 외부 단편화 : 프로그램이 할당될 수 없어 사용되지 않고 빈공간으로 남아있는 분할된 전체 영역

<br/>

**페이징(Paging) 기법** 

가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법.

- 내부 단편화 발생

- 주소 변환을 위해 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블 사용, 비용 증가, 처리 속도 감소

* 페이지 : 프로그램을 일정한 크기로 나눈 단위

* 페이지 프레임 : 페이지 크기로 일정하게 나누어진 주기억장치의 단위

 

**세그먼테이션(Segmentation) 기법**

가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법

- 각 세그먼트는 고유한 이름과 크기를 가짐

- 외부 단편화 발생

- 기억공간 절약

- 세그먼트 맵 테이블 사용

- 다른 세크먼트에게 할당된 영역을 침범할 수 없으며, 기억장치 보호키 필요

- 매핑(Mapping) : 가상기억장치에서 주기억장치로 페이지를 옮겨 넣을 때 주소를 조정해 주는 것

#### 세그먼트 기법의 일반적인 주소 변환

- 가상주소 형식 : 세그먼트 번호(s) | 변위값(d)
  - 변위값 : 세그먼트 내의 실제 내용이 위치하고 있는 곳 까지의 거리

- 실 기억주소 : 세그먼트의 기준번지와 변위값을 더함으로써 얻읃 수 있음

<br/>

## 페이지 교체 알고리즘의 개요

페이지 교체 알고리즘은 페이지 부재가 발생했을 때 가상기억장치의 필요 페이지를 주기억장치에 적재해야 하는데 어떤 페이지 프레임을 선택해 교체할 것인지를 결정하는 기법이다.

- 페이지 부제(Page Fault) : CPU가 엑세스한 가상 페이지가 주기억장치에 없는 경우를 말한다.

-  페이지 교체 알고리즘에는 FIFO, LRU, OPT, LFU, NUR등이 있다.

**FIFO (First In First Out)**

- 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법

- 각 페이지가 주기억장치에 들어올 때마다 타임스탬프를 찍어 기억하는 방식

- 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.

- 벨레이디의 모순(Belady's Anomaly) : 프레임수가 많아질수록 페이지 결함이 적게 발생할 것 같지만, 그렇지 않음


**LRU(Least Recently Used)**

- LRU는 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다.

- 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체한다.
  - 계수기(Counter) : 각 페이지별로 존재하는 논리적 시계로, 해당 페이지가 사용될 때마다 0으로 클리어 시킨후 시간을 증가시킨다.
  
  - 교체 페이지 선정 방법 : 현 시점까지 참조된 페이지 번호 순서를 거꾸로 검사하여 중복되지 않고 가장 나중에 나타나는 페이지를 선택한다.


**LFU(Least Frequently Used)**

- LFU는 사용 빈도가 가장 적은 페이지를 교체하는 기법이다.

- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.

- 바로 불러온 페이지가 교체될 수 있다는 단점이 존재함.


**NUR (Not Used Recently)**

- LRU와 비슷한 방식으로, 최근에 사용하지 않은 페이지를 교체

- LRU 교체의 단점인 시간 오버헤드를 적게하는 방법

- 최근 사용여부를 확인하기 위해 각 페이지마다 두개의 비트 (참조비트(Reference Bit)/ 변형비트(Dirty Bit))를 사용

- 참조비트 : 페이지가 호출되었을 때는 1, 호출되지 않았을 때는 0

- 변형비트 : 페이지 내용이 변경되었을 때는 1, 변경되지 않았을 때는 0