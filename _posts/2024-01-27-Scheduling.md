---
title : "[스케줄링]스케줄링에 대해서 알아보자 "

excerpt : "스케줄링의 개요, 기법"

categories:
- 운영체제

tags: 
- [Blog, Github, Git, Process]

last_modified_at : "2024-01-27"
  

toc: true
toc_sticky: true
pin: true
---

## 스케줄링의 개요

스케줄링(Scheduling)은 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미한다.

- 프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 된다.

<br/>

## 프로세서(스) 스케줄링의 기법

- 비선점(Non-preemptive)스케줄링
  - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없다.
  
  - 비선점 스케줄링의 종류에는 FCFS(FIFO), SJF, 우선순위, HRN, 기한부 등의 알고리즘이 있다.
  
- 선점(Preemptive)스케줄링
  - 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법이다.

  - 선점 스케줄링의 종류에는 Round Robin, SRT, 선점 우선순위, 다단계 큐(MQ), 다단계 피드백 큐(MFQ)등의 알고리즘이 있다.

<br/>

## 주요 스케줄링 기법

**1.  FCFS(First Come First Service, 선입 선출) = FIFO(First in First Out)**

FCFS는 준비상태 큐(대기 큐, 준비 완료 리스트 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라 차례로 CPU를 할당하는 기법.

#### 예제

![image](https://github.com/taeyoung0/taeyoung0.github.io/assets/115425415/5d16499b-182f-4564-bc47-64da0d44122e)

반환 시간과 대기 시간을 구해보자.

- 반환 시간 = 프로세스가 시작해서 끝날 때까지 걸리는 시간 (완료 시간 - 도착 시간)


- 대기 시간 = 프로세스가 준비 상태에서 대기한 시간 (시작 시간 - 도착 시간)


![image](https://github.com/taeyoung0/taeyoung0.github.io/assets/115425415/4b5303a3-15a4-48a0-92e0-5181e20368f7)

<br/>

**2. SJF(Shortest Job First, 단기 작업 우선)**

SJF는 준비상태 큐에서 기다리고 있는 프로세스를 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법.


#### 예제

![image](https://github.com/taeyoung0/taeyoung0.github.io/assets/115425415/a3476e21-81d8-4c88-811d-5c9439a9d73d)

- p1은 전에 아무 프로세스가 없기 때문에 바로 실행한다.

- p1의 실행 시간이 1일때, 2일때, 3일때, 4일때 각각 p2, p3, p4, p5가 들어온다.

- 각각의 프로세스 실행 시간을 비교하여 가장 짧은 프로세스 p4를 인지하고 p4를 실행 시킨다.

- p4의 실행이 끝나고 나서 그 다음의 실행 시간이 짧은 p3를 실행시킨다.

- p3의 실행이 끝나고 그 다음 실행 시간이 짧은 p5를 실행 시킨다.

- p5의 실행이 끝나고 그 다음 실행 시간이 짧은 p2를 실행 시킨다.


![image](https://github.com/taeyoung0/taeyoung0.github.io/assets/115425415/0ba4896a-6aef-4a70-be0a-acf29401491c)

**3. HRN(Highest Response-ratio Next)**

HRN은 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법이다.

- 우선순위 = (대기 시간 + 서비스 시간) / 서비스 시간 이 큰 순서

- P1 실행시간 : 20 , 대기시간 : 10 

- P2 실행시간 : 4 , 대기시간 : 20

- P3 실행시간 : 6, 대기시간 : 10  

  - P1 = (20 + 10) / 20 = 1.5 
  
  - P2 = (4 + 20) / 4 = 6
  
  - P3 = (6 + 10) / 6 = 2.6 
  
  - P2 --> P3 --> P1 의 순서로 진행된다.

<br/>

**4. RP(Round Robin)**

RP(Round Robin)는 시분할 시스템(Time Sharing System)을 위해 고안된 방식으로, FCFS 알고리즘을 선점 형태로 변형한 기법이다.

- 할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생된다.


#### 예제 (Time Slice는 4초이다)

| 프로세스 번호 |    P1  |    P2    |    P3   |
| ------------ | ------- | ------- | --------|
|   실행 시간   |     20   |    4    |    6    |

- 주어진 시간 할당량(Time Slice)동안 실행되지 못할 경우 준비상태 큐의 가장 마지막으로 재배치.

- 진행시간 별로 보자.
  
  - P1 실행 0 -> 4 (실행 시간 4초)
  
  - P2 실행 4 -> 8 (실행 시간 4초) P2 완료
  
  - P3 실행 8 -> 12 (실행 시간 4초)
  
  - P1 실행 12 -> 16 (실행 시간 4초)
  
  - P3 실행 16 -> 18 (실행 시간 2초) P3 완료
  
  - P1 실행 18 -> 22 (실행 시간 4초)
  
  - P1 실행 22 -> 26 (실행 시간 4초)
  
  - P1 실행 26 -> 30 (실행 시간 4초) P1 완료


